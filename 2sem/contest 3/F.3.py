import cmath


# Функция для выполнения Быстрого преобразования Фурье (FFT)
def fft(a, invert):
    n = len(a)

    # Базовый случай для рекурсии: если длина массива равна 1
    if n == 1:
        return a

    # Разделяем массив на чётные и нечётные элементы
    a_even = fft(a[0::2], invert)  # Чётные индексы
    a_odd = fft(a[1::2], invert)  # Нечётные индексы

    # Угловой коэффициент для корней единицы (используем для вращения)
    angle = 2 * cmath.pi / n * (-1 if invert else 1)
    w = 1
    wn = cmath.rect(1, angle)  # Возводим e в степень угла

    # Результирующий массив
    y = [0] * n
    for k in range(n // 2):
        u = a_even[k]
        v = w * a_odd[k]

        # Формируем два новых значения в массиве
        y[k] = u + v
        y[k + n // 2] = u - v

        # Если мы инвертируем (обратное преобразование), делим на 2
        if invert:
            y[k] /= 2
            y[k + n // 2] /= 2

        # Обновляем w для следующего шага
        w *= wn

    return y


# Функция для свертки двух векторов с помощью FFT
def convolution(a, b):
    n = 1
    # Находим минимальную степень двойки, которая покрывает длину суммы двух массивов
    while n < len(a) + len(b):
        n *= 2

    # Дополняем массивы нулями до длины n
    while len(a) < n:
        a.append(0)
    while len(b) < n:
        b.append(0)

    # Применяем FFT к обоим массивам
    fa = fft(a, False)
    fb = fft(b, False)

    # Перемножаем соответствующие элементы
    for i in range(n):
        fa[i] *= fb[i]

    # Применяем обратное преобразование для получения результата свертки
    result = fft(fa, True)

    # Возвращаем только вещественные части результатов, округляя их
    result_real = [round(result[i].real) for i in range(len(result))]
    return result_real


# Функция для кодирования строки в бинарный вектор по символу
def encode(s, ch):
    encoded = []
    # Для каждого символа в строке добавляем 1, если символ совпадает с ch, иначе 0
    for c in s:
        if c == ch:
            encoded.append(1)
        else:
            encoded.append(0)
    return encoded


# Основная функция для нахождения максимального совпадения при циклических сдвигах
def max_cyclic_match_fft(s1, s2):
    M = len(s1)
    max_match = 0

    # Для каждого символа из набора 'A', 'C', 'G', 'T'
    for ch in 'ACGT':
        # Кодируем строки для текущего символа
        vec1 = encode(s1, ch)
        vec2 = encode(s2[::-1], ch)  # Переворачиваем вторую строку для корректной работы свертки
        vec1 = vec1 + vec1  # Удваиваем первый вектор для циклической свертки

        # Вычисляем свертку двух векторов
        conv = convolution(vec1, vec2)

        # Находим максимальное совпадение для всех допустимых циклических сдвигов
        max_match_for_ch = max(conv[M - 1: 2 * M - 1])
        max_match += max_match_for_ch  # Добавляем результат для этого символа

    return max_match


# Ввод данных
s1 = input()  # Ввод первой строки
s2 = input()  # Ввод второй строки

# Выводим максимальное количество совпадений
print(max_cyclic_match_fft(s1, s2))